//! Core keyboard event types.

use std::fmt::{self, Write};
use std::hash::{Hash, Hasher};

use vtansi::AnsiEvent;

use super::keycode::KeyCode;
use super::modifier::{KeyEventKind, KeyEventState, KeyModifiers};
use vtansi::TerseDisplay;

/// Represents a key event.
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[derive(Debug, PartialOrd, Clone)]
pub struct KeyEvent {
    /// The key itself.
    pub code: KeyCode,
    /// Additional key modifiers.
    pub modifiers: KeyModifiers,
    /// Kind of event.
    ///
    /// Only set if [`KeyboardEnhancementFlags::REPORT_EVENT_TYPES`](super::KeyboardEnhancementFlags::REPORT_EVENT_TYPES) has been
    /// enabled with [`PushKeyboardEnhancementFlags`](super::PushKeyboardEnhancementFlags).
    pub kind: KeyEventKind,
    /// Keyboard state.
    ///
    /// Only set if [`KeyboardEnhancementFlags::DISAMBIGUATE_ESCAPE_CODES`](super::KeyboardEnhancementFlags::DISAMBIGUATE_ESCAPE_CODES) has
    /// been enabled with [`PushKeyboardEnhancementFlags`](super::PushKeyboardEnhancementFlags).
    pub state: KeyEventState,
    /// Base layout key for cross-layout shortcut matching.
    ///
    /// This represents the key in the standard PC-101 layout that corresponds
    /// to the physical key pressed. For example, on a Cyrillic keyboard
    /// layout, pressing the physical key that produces 'ะก' (Cyrillic) would
    /// have `base_layout_key` set to Some('c') (Latin), allowing Ctrl+C
    /// shortcuts to work regardless of keyboard layout.
    ///
    /// Only set if [`KeyboardEnhancementFlags::REPORT_ALTERNATE_KEYS`](super::KeyboardEnhancementFlags::REPORT_ALTERNATE_KEYS) has
    /// been enabled with [`PushKeyboardEnhancementFlags`](super::PushKeyboardEnhancementFlags).
    pub base_layout_key: Option<KeyCode>,
    /// Associated text as Unicode codepoints.
    ///
    /// This represents the actual text generated by the key press,
    /// which may differ from the key code when modifiers or keyboard
    /// layouts are involved. For example, `Shift+A` would have key code 'a'
    /// but text "A".
    ///
    /// Only set if [`KeyboardEnhancementFlags::REPORT_ASSOCIATED_TEXT`](super::KeyboardEnhancementFlags::REPORT_ASSOCIATED_TEXT) has
    /// been enabled with [`PushKeyboardEnhancementFlags`](super::PushKeyboardEnhancementFlags).
    pub text: Option<String>,
}

/// Builder for constructing [`KeyEvent`] instances.
///
/// # Example
///
/// ```
/// use vtio::event::keyboard::{KeyEvent, KeyCode, KeyModifiers, KeyEventKind};
///
/// let event = KeyEvent::builder(KeyCode::Char('c'), KeyModifiers::CONTROL)
///     .kind(KeyEventKind::Press)
///     .build();
/// ```
#[derive(Debug, Clone)]
pub struct KeyEventBuilder {
    code: KeyCode,
    modifiers: KeyModifiers,
    kind: KeyEventKind,
    state: KeyEventState,
    base_layout_key: Option<KeyCode>,
    text: Option<String>,
}

impl KeyEventBuilder {
    /// Create a new builder with the required code and modifiers.
    #[must_use]
    pub const fn new(code: KeyCode, modifiers: KeyModifiers) -> Self {
        Self {
            code,
            modifiers,
            kind: KeyEventKind::Press,
            state: KeyEventState::empty(),
            base_layout_key: None,
            text: None,
        }
    }

    /// Set the event kind (Press, Repeat, or Release).
    #[must_use]
    pub const fn kind(mut self, kind: KeyEventKind) -> Self {
        self.kind = kind;
        self
    }

    /// Set the keyboard state flags.
    #[must_use]
    pub const fn state(mut self, state: KeyEventState) -> Self {
        self.state = state;
        self
    }

    /// Set the base layout key for cross-layout shortcut matching.
    #[must_use]
    pub const fn base_layout_key(mut self, key: KeyCode) -> Self {
        self.base_layout_key = Some(key);
        self
    }

    /// Set additional modifiers (combines with existing modifiers).
    #[must_use]
    pub const fn modifiers(mut self, modifiers: KeyModifiers) -> Self {
        self.modifiers = self.modifiers.union(modifiers);
        self
    }

    /// Set the associated text.
    #[must_use]
    pub fn text(mut self, text: String) -> Self {
        self.text = Some(text);
        self
    }

    /// Build the `KeyEvent`.
    #[must_use]
    pub fn build(self) -> KeyEvent {
        KeyEvent {
            code: self.code,
            modifiers: self.modifiers,
            kind: self.kind,
            state: self.state,
            base_layout_key: self.base_layout_key,
            text: self.text,
        }
    }
}

impl From<KeyEventBuilder> for KeyEvent {
    fn from(builder: KeyEventBuilder) -> Self {
        builder.build()
    }
}

impl KeyEvent {
    /// Create a new key event with the given code and modifiers.
    ///
    /// This creates a Press event with no additional state.
    /// For more control, use [`KeyEvent::builder`].
    #[must_use]
    pub const fn new(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent {
        KeyEvent {
            code,
            modifiers,
            kind: KeyEventKind::Press,
            state: KeyEventState::empty(),
            base_layout_key: None,
            text: None,
        }
    }

    /// Create a builder for constructing a `KeyEvent` with additional options.
    #[must_use]
    pub const fn builder(
        code: KeyCode,
        modifiers: KeyModifiers,
    ) -> KeyEventBuilder {
        KeyEventBuilder::new(code, modifiers)
    }

    /// Returns the normalized (code, modifiers) for comparison/hashing.
    ///
    /// For character keys, normalizes case so that `Char('d')` + `SHIFT` equals
    /// `Char('D')`. Returns the uppercase char with SHIFT modifier set.
    #[inline]
    pub(crate) fn normalized_code_and_modifiers(
        &self,
    ) -> (KeyCode, KeyModifiers) {
        if let KeyCode::Char(c) = self.code {
            if c.is_ascii_lowercase()
                && self.modifiers.contains(KeyModifiers::SHIFT)
            {
                (KeyCode::Char(c.to_ascii_uppercase()), self.modifiers)
            } else if c.is_ascii_uppercase() {
                (self.code, self.modifiers | KeyModifiers::SHIFT)
            } else {
                (self.code, self.modifiers)
            }
        } else {
            (self.code, self.modifiers)
        }
    }

    /// Returns the normalized `base_layout_key` for comparison/hashing.
    #[inline]
    fn normalized_base_layout_key(&self, has_shift: bool) -> Option<KeyCode> {
        match self.base_layout_key {
            Some(KeyCode::Char(c)) if c.is_ascii_lowercase() && has_shift => {
                Some(KeyCode::Char(c.to_ascii_uppercase()))
            }
            other => other,
        }
    }

    /// Returns whether the key event is a press event.
    #[must_use]
    pub fn is_press(&self) -> bool {
        matches!(self.kind, KeyEventKind::Press)
    }

    /// Returns whether the key event is a release event.
    #[must_use]
    pub fn is_release(&self) -> bool {
        matches!(self.kind, KeyEventKind::Release)
    }

    /// Returns whether the key event is a repeat event.
    #[must_use]
    pub fn is_repeat(&self) -> bool {
        matches!(self.kind, KeyEventKind::Repeat)
    }

    /// Return the base layout key for cross-layout shortcut matching.
    ///
    /// This returns the key in the standard PC-101 layout that corresponds
    /// to the physical key pressed, useful for matching shortcuts across
    /// different keyboard layouts.
    #[must_use]
    pub fn base_layout_key(&self) -> Option<KeyCode> {
        self.base_layout_key
    }

    /// Check if this key event matches a key code, considering the base
    /// layout key for cross-layout matching.
    ///
    /// This is useful for shortcut matching where you want Ctrl+C to work
    /// regardless of keyboard layout.
    #[must_use]
    pub fn matches_key(&self, key: KeyCode) -> bool {
        self.code == key || self.base_layout_key == Some(key)
    }

    /// Return the associated text generated by this key event.
    ///
    /// This is the actual text that would be inserted by the key press,
    /// which may differ from the key code when modifiers or keyboard
    /// layouts are involved.
    #[must_use]
    pub fn text(&self) -> Option<&str> {
        self.text.as_deref()
    }
}

impl TerseDisplay for KeyEvent {
    fn terse_fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("key(")?;
        self.kind.terse_fmt(f)?;

        if self.modifiers.is_empty() {
            f.write_char(':')?;
        } else {
            f.write_char(':')?;
            self.modifiers.terse_fmt(f)?;
            f.write_char('-')?;
        }

        self.code.terse_fmt(f)?;

        if !self.state.is_empty() {
            const STATES: &[(KeyEventState, &str)] = &[
                (KeyEventState::KEYPAD, ":keypad"),
                (KeyEventState::CAPS_LOCK, ":caps_lock"),
                (KeyEventState::NUM_LOCK, ":num_lock"),
            ];
            for (state, name) in STATES {
                if self.state.contains(*state) {
                    f.write_str(name)?;
                }
            }
        }

        if let Some(base_key) = self.base_layout_key {
            f.write_str(":base=")?;
            base_key.terse_fmt(f)?;
        }

        if let Some(text) = &self.text {
            f.write_str(":text=\"")?;
            for c in text.chars() {
                if c == '"' {
                    f.write_str("\\\"")?;
                } else if c == '\\' {
                    f.write_str("\\\\")?;
                } else if c.is_control() {
                    write!(f, "\\u{{{:x}}}", c as u32)?;
                } else {
                    f.write_char(c)?;
                }
            }
            f.write_char('"')?;
        }

        f.write_char(')')
    }
}

impl From<KeyCode> for KeyEvent {
    fn from(code: KeyCode) -> Self {
        KeyEvent {
            code,
            modifiers: KeyModifiers::NONE,
            kind: KeyEventKind::Press,
            state: KeyEventState::NONE,
            base_layout_key: None,
            text: None,
        }
    }
}

impl PartialEq for KeyEvent {
    fn eq(&self, other: &KeyEvent) -> bool {
        let (lhs_code, lhs_mods) = self.normalized_code_and_modifiers();
        let (rhs_code, rhs_mods) = other.normalized_code_and_modifiers();

        lhs_code == rhs_code
            && lhs_mods == rhs_mods
            && self.kind == other.kind
            && self.state == other.state
            && self.normalized_base_layout_key(
                lhs_mods.contains(KeyModifiers::SHIFT),
            ) == other.normalized_base_layout_key(
                rhs_mods.contains(KeyModifiers::SHIFT),
            )
            && self.text == other.text
    }
}

impl Eq for KeyEvent {}

impl Hash for KeyEvent {
    fn hash<H: Hasher>(&self, hash_state: &mut H) {
        let (code, modifiers) = self.normalized_code_and_modifiers();
        code.hash(hash_state);
        modifiers.hash(hash_state);
        self.kind.hash(hash_state);
        self.state.hash(hash_state);
        self.normalized_base_layout_key(
            modifiers.contains(KeyModifiers::SHIFT),
        )
        .hash(hash_state);
        self.text.hash(hash_state);
    }
}

impl AnsiEvent<'_> for KeyEvent {
    #[inline]
    fn ansi_control_kind(&self) -> Option<vtansi::AnsiControlFunctionKind> {
        None
    }

    #[inline]
    fn ansi_direction(&self) -> vtansi::AnsiControlDirection {
        vtansi::AnsiControlDirection::Input
    }

    vtansi::impl_ansi_event_encode!();
    vtansi::impl_ansi_event_terse_fmt!();
}

better_any::tid! {KeyEvent}
