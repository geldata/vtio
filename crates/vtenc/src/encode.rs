//! Encoding and decoding utilities for ANSI control sequences.
//!
//! This module provides traits and utilities for converting between typed
//! Rust values and ANSI byte sequences.
//!
//! # Encoding
//!
//! The [`AnsiEncode`] trait is the primary interface for encoding values into
//! ANSI sequences. Types can implement this trait directly, or implement
//! [`ToAnsi`] for a more ergonomic conversion.
//!
//! For types that always encode to a constant string, implement
//! [`StaticAnsiEncode`] which provides automatic implementations of the other
//! encoding traits.
//!
//! # Decoding (Parsing)
//!
//! The decoding trait system supports both fixed-length and variable-length
//! parsing:
//!
//! ## Fixed-Length Parsing
//!
//! For types that require exactly N bytes to parse, use the
//! [`fixed_length_ansi!`] macro which implements both [`TryFromAnsiBytes<N>`]
//! and the bridge to [`TryFromAnsi`]:
//!
//! ```ignore
//! struct RgbColor { r: u8, g: u8, b: u8 }
//!
//! fixed_length_ansi! {
//!     impl TryFromAnsiBytes<3> for RgbColor {
//!         fn try_from_ansi_bytes(bytes: &[u8; 3]) -> Result<Self, ParseError> {
//!             Ok(RgbColor { r: bytes[0], g: bytes[1], b: bytes[2] })
//!         }
//!     }
//! }
//! // TryFromAnsi is automatically generated by the macro!
//! ```
//!
//! ## Variable-Length Parsing
//!
//! For types that accept variable-length input, implement [`TryFromAnsi`]
//! directly:
//!
//! ```ignore
//! impl<'a> TryFromAnsi<'a> for MyType {
//!     fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, ParseError> {
//!         // Parse bytes of any length
//!         Ok(MyType { /* ... */ })
//!     }
//! }
//! ```
//!
//! ## Infallible Parsing
//!
//! For types that can always be parsed successfully, implement [`FromAnsi`]
//! or [`FromAnsiBytes<N>`] instead of their fallible counterparts.
//!
//! # Utility Functions
//!
//! This module provides several utility functions for common parsing patterns:
//!
//! - [`parse_single_byte`]: Parse exactly one byte
//! - [`parse_utf8_str`]: Validate and parse UTF-8
//! - [`parse_int`]: Parse ASCII digits into an integer
//! - [`split_on_byte`]: Split a byte slice on a delimiter

use core::fmt;
use std::io::{self, Write};

/// Write an integer to a buffer without allocation.
///
/// Uses the `itoa` crate for efficient integer-to-string conversion.
///
/// # Errors
///
/// Return an error if the buffer is too small to hold the integer.
#[inline]
pub fn write_int<W: io::Write + ?Sized>(
    sink: &mut W,
    value: impl itoa::Integer,
) -> Result<usize, EncodeError> {
    let mut buffer = itoa::Buffer::new();
    let s = buffer.format(value);
    write_str_into(sink, s)
}

pub struct CountingWriter<W> {
    inner: W,
    written: usize,
    overflow: usize,
}

impl<W: io::Write> CountingWriter<W> {
    #[inline]
    pub fn new(inner: W) -> Self {
        Self {
            inner,
            written: 0,
            overflow: 0,
        }
    }
    #[inline]
    pub fn written(&self) -> usize {
        self.written
    }
    #[inline]
    pub fn overflow(&self) -> usize {
        self.overflow
    }
    #[inline]
    pub fn into_inner(self) -> W {
        self.inner
    }
}

impl<W: io::Write> io::Write for CountingWriter<W> {
    #[inline]
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        let requested = buf.len();
        let n = self.inner.write(buf)?;
        self.written += n;
        if n < requested {
            self.overflow += requested - n;
        }
        Ok(n)
    }
    fn flush(&mut self) -> io::Result<()> {
        self.inner.flush()
    }
}

/// Copy a byte slice into the provided sink,
/// returning the number of bytes written.
///
/// # Errors
///
/// Return an error if the buffer is too small to hold the data.
#[inline]
pub fn write_bytes_into<W: io::Write + ?Sized>(
    sink: &mut W,
    s: &[u8],
) -> Result<usize, EncodeError> {
    let mut w = CountingWriter::new(sink);
    match w.write(s) {
        Err(ref e) if e.kind() == io::ErrorKind::WriteZero => {
            Err(EncodeError::BufferOverflow(w.overflow()))
        }
        Err(e) => Err(EncodeError::IOError(e)),
        Ok(_n) if w.overflow() > 0 => Err(EncodeError::BufferOverflow(w.overflow())),
        Ok(n) => Ok(n),
    }
}

/// Copy a UTF-8 string into the provided buffer,
/// returning the number of bytes written.
///
/// # Errors
///
/// Return an error if the buffer is too small to hold the string.
#[inline]
pub fn write_str_into<W: io::Write + ?Sized>(sink: &mut W, s: &str) -> Result<usize, EncodeError> {
    write_bytes_into(sink, s.as_bytes())
}

/// Trait for types that can be efficiently written to a buffer.
///
/// This trait is implemented for string slices and integer types, allowing
/// the `write_*` macros to accept a sequence of literals and integers
/// without heap allocation or the overhead of `write_fmt`.
pub trait AnsiEncode {
    /// Write this value to the buffer.
    ///
    /// # Errors
    ///
    /// Return an error if the buffer is too small to hold the value.
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError>;

    /// Encode this value as an ANSI control sequence directly into a byte slice.
    ///
    /// # Errors
    ///
    /// Return an error if the buffer is too small to hold the encoded value.
    #[inline]
    fn encode_ansi_into_slice(&self, buf: &mut [u8]) -> Result<usize, EncodeError> {
        self.encode_ansi_into(&mut &mut buf[..])
    }

    /// Encode this value as an ANSI control sequence and return the resulting bytes.
    ///
    /// # Errors
    ///
    /// Return an error if the buffer is too small to hold the encoded value.
    #[inline]
    fn encode_ansi(&self) -> Result<Vec<u8>, EncodeError> {
        let mut v: Vec<u8> = Vec::with_capacity(5);
        self.encode_ansi_into(&mut v)?;
        Ok(v)
    }
}

pub trait ToAnsi {
    fn to_ansi(&self) -> impl AnsiEncode;
}

impl<T: ToAnsi> AnsiEncode for T {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        self.to_ansi().encode_ansi_into(sink)
    }
}

/// Parse a value from an ANSI byte slice infallibly.
///
/// This trait is for types that can always be successfully parsed from
/// a byte slice, such as types with default values or types that accept
/// any input.
pub trait FromAnsi<'a>: Sized {
    /// Parse a value from an ANSI byte slice.
    fn from_ansi(bytes: &'a [u8]) -> Self;
}

/// Parse a value from an ANSI byte slice with error handling.
///
/// This is the primary trait for parsing ANSI sequences. Types with
/// fixed-length requirements should implement `TryFromAnsiBytes` instead,
/// which can be bridged to this trait using helper methods.
pub trait TryFromAnsi<'a>: Sized {
    /// Parse a value from an ANSI byte slice.
    ///
    /// # Errors
    ///
    /// Return an error if the byte slice is invalid for this type.
    fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, ParseError>;
}

/// Parse a value from a fixed-length ANSI byte array.
///
/// This trait is for types that require exactly N bytes to parse.
/// Use the [`fixed_length_ansi!`] macro to implement this trait and
/// automatically generate the bridge to [`TryFromAnsi`].
///
/// The lifetime parameter `'a` allows for zero-copy parsing where the
/// result may contain references to the input bytes.
pub trait TryFromAnsiBytes<'a, const N: usize>: Sized {
    /// Parse a value from a fixed-length ANSI byte array.
    ///
    /// # Errors
    ///
    /// Return an error if the byte array is invalid for this type.
    fn try_from_ansi_bytes(bytes: &'a [u8; N]) -> Result<Self, ParseError>;
}

/// Parse a value from a fixed-length ANSI byte array infallibly.
///
/// This trait is for types that can always be successfully parsed from
/// a fixed-length byte array.
///
/// The lifetime parameter `'a` allows for zero-copy parsing where the
/// result may contain references to the input bytes.
pub trait FromAnsiBytes<'a, const N: usize>: Sized {
    /// Parse a value from a fixed-length ANSI byte array.
    fn from_ansi_bytes(bytes: &'a [u8; N]) -> Self;
}

/// Macro to implement `TryFromAnsiBytes<N>` and automatically generate
/// the bridge to `TryFromAnsi`.
///
/// This macro takes an impl block for `TryFromAnsiBytes<N>` and generates:
/// 1. The provided impl block
/// 2. A bridge impl for `TryFromAnsi` that validates slice length
///
/// # Example (Owned Types)
///
/// ```ignore
/// fixed_length_ansi! {
///     impl TryFromAnsiBytes<3> for RgbColor {
///         fn try_from_ansi_bytes(bytes: &[u8; 3]) -> Result<Self, ParseError> {
///             Ok(RgbColor { r: bytes[0], g: bytes[1], b: bytes[2] })
///         }
///     }
/// }
/// ```
///
/// # Example (Zero-Copy with Lifetimes)
///
/// For types that borrow from the input, add an explicit lifetime parameter:
///
/// ```ignore
/// fixed_length_ansi! {
///     impl<'a> TryFromAnsiBytes<5> for AnsiStr<'a> {
///         fn try_from_ansi_bytes(bytes: &[u8; 5]) -> Result<Self, ParseError> {
///             let s = std::str::from_utf8(bytes)?;
///             Ok(AnsiStr(s))
///         }
///     }
/// }
/// ```
///
/// # Example (Infallible Parsing)
///
/// For infallible parsing, use `FromAnsiBytes` instead:
///
/// ```ignore
/// fixed_length_ansi! {
///     impl FromAnsiBytes<1> for bool {
///         fn from_ansi_bytes(bytes: &[u8; 1]) -> Self {
///             bytes[0] != 0
///         }
///     }
/// }
/// ```
#[macro_export]
macro_rules! fixed_length_ansi {
    // Fallible variant: TryFromAnsiBytes with explicit lifetime
    (
        $(#[$meta:meta])*
        impl<$lt:lifetime> TryFromAnsiBytes<$len:literal> for $type:ty {
            fn try_from_ansi_bytes($bytes:ident: &[u8; $len2:literal]) -> Result<Self, $error:ty> {
                $($body:tt)*
            }
        }
    ) => {
        $(#[$meta])*
        impl<$lt> $crate::encode::TryFromAnsiBytes<$lt, $len> for $type {
            fn try_from_ansi_bytes($bytes: &$lt [u8; $len]) -> Result<Self, $crate::encode::ParseError> {
                $($body)*
            }
        }

        impl<$lt> $crate::encode::TryFromAnsi<$lt> for $type {
            #[inline]
            fn try_from_ansi(bytes: &$lt [u8]) -> Result<Self, $crate::encode::ParseError> {
                let arr: &$lt [u8; $len] = bytes.try_into().map_err(|_| {
                    $crate::encode::ParseError::WrongLen {
                        expected: $len,
                        got: bytes.len(),
                    }
                })?;
                <$type as $crate::encode::TryFromAnsiBytes<$lt, $len>>::try_from_ansi_bytes(arr)
            }
        }
    };

    // Fallible variant: TryFromAnsiBytes without lifetime (owned types)
    (
        $(#[$meta:meta])*
        impl TryFromAnsiBytes<$len:literal> for $type:ty {
            fn try_from_ansi_bytes($bytes:ident: &[u8; $len2:literal]) -> Result<Self, $error:ty> {
                $($body:tt)*
            }
        }
    ) => {
        $(#[$meta])*
        impl<'a> $crate::encode::TryFromAnsiBytes<'a, $len> for $type {
            fn try_from_ansi_bytes($bytes: &'a [u8; $len]) -> Result<Self, $crate::encode::ParseError> {
                $($body)*
            }
        }

        impl<'a> $crate::encode::TryFromAnsi<'a> for $type {
            #[inline]
            fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, $crate::encode::ParseError> {
                let arr: &'a [u8; $len] = bytes.try_into().map_err(|_| {
                    $crate::encode::ParseError::WrongLen {
                        expected: $len,
                        got: bytes.len(),
                    }
                })?;
                <$type as $crate::encode::TryFromAnsiBytes<'a, $len>>::try_from_ansi_bytes(arr)
            }
        }
    };

    // Infallible variant: FromAnsiBytes with explicit lifetime
    (
        $(#[$meta:meta])*
        impl<$lt:lifetime> FromAnsiBytes<$len:literal> for $type:ty {
            fn from_ansi_bytes($bytes:ident: &[u8; $len2:literal]) -> Self {
                $($body:tt)*
            }
        }
    ) => {
        $(#[$meta])*
        impl<$lt> $crate::encode::FromAnsiBytes<$lt, $len> for $type {
            fn from_ansi_bytes($bytes: &$lt [u8; $len]) -> Self {
                $($body)*
            }
        }

        impl<$lt> $crate::encode::TryFromAnsiBytes<$lt, $len> for $type {
            #[inline]
            fn try_from_ansi_bytes(bytes: &$lt [u8; $len]) -> Result<Self, $crate::encode::ParseError> {
                Ok(<$type as $crate::encode::FromAnsiBytes<$lt, $len>>::from_ansi_bytes(bytes))
            }
        }

        impl<$lt> $crate::encode::TryFromAnsi<$lt> for $type {
            #[inline]
            fn try_from_ansi(bytes: &$lt [u8]) -> Result<Self, $crate::encode::ParseError> {
                let arr: &$lt [u8; $len] = bytes.try_into().map_err(|_| {
                    $crate::encode::ParseError::WrongLen {
                        expected: $len,
                        got: bytes.len(),
                    }
                })?;
                Ok(<$type as $crate::encode::FromAnsiBytes<$lt, $len>>::from_ansi_bytes(arr))
            }
        }
    };

    // Infallible variant: FromAnsiBytes without lifetime (owned types)
    (
        $(#[$meta:meta])*
        impl FromAnsiBytes<$len:literal> for $type:ty {
            fn from_ansi_bytes($bytes:ident: &[u8; $len2:literal]) -> Self {
                $($body:tt)*
            }
        }
    ) => {
        $(#[$meta])*
        impl<'a> $crate::encode::FromAnsiBytes<'a, $len> for $type {
            fn from_ansi_bytes($bytes: &'a [u8; $len]) -> Self {
                $($body)*
            }
        }

        impl<'a> $crate::encode::TryFromAnsiBytes<'a, $len> for $type {
            #[inline]
            fn try_from_ansi_bytes(bytes: &'a [u8; $len]) -> Result<Self, $crate::encode::ParseError> {
                Ok(<$type as $crate::encode::FromAnsiBytes<'a, $len>>::from_ansi_bytes(bytes))
            }
        }

        impl<'a> $crate::encode::TryFromAnsi<'a> for $type {
            #[inline]
            fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, $crate::encode::ParseError> {
                let arr: &'a [u8; $len] = bytes.try_into().map_err(|_| {
                    $crate::encode::ParseError::WrongLen {
                        expected: $len,
                        got: bytes.len(),
                    }
                })?;
                Ok(<$type as $crate::encode::FromAnsiBytes<'a, $len>>::from_ansi_bytes(arr))
            }
        }
    };
}
/// Parse a single byte from an ANSI sequence.
///
/// # Errors
///
/// Return an error if the slice is empty or contains more than one byte.
#[inline]
pub fn parse_single_byte(bytes: &[u8]) -> Result<u8, ParseError> {
    match bytes {
        [] => Err(ParseError::Empty),
        [byte] => Ok(*byte),
        _ => Err(ParseError::WrongLen {
            expected: 1,
            got: bytes.len(),
        }),
    }
}

/// Parse a UTF-8 string from an ANSI sequence.
///
/// # Errors
///
/// Return an error if the bytes are not valid UTF-8.
#[inline]
pub fn parse_utf8_str(bytes: &[u8]) -> Result<&str, ParseError> {
    std::str::from_utf8(bytes).map_err(|_| ParseError::InvalidUtf8)
}

/// Parse an integer from ASCII digits in an ANSI sequence.
///
/// This function parses decimal ASCII digits (0-9) into an integer.
///
/// # Errors
///
/// Return an error if the slice is empty, contains non-digit bytes,
/// or the value overflows the target type.
#[inline]
pub fn parse_int<T>(bytes: &[u8]) -> Result<T, ParseError>
where
    T: Default + core::ops::Mul<Output = T> + core::ops::Add<Output = T> + From<u8> + PartialOrd + Copy,
{
    if bytes.is_empty() {
        return Err(ParseError::Empty);
    }

    let mut result = T::default();
    let ten = T::from(10);

    for (pos, &byte) in bytes.iter().enumerate() {
        if !byte.is_ascii_digit() {
            return Err(ParseError::InvalidByte { pos, byte });
        }
        let digit = T::from(byte - b'0');
        result = result * ten + digit;
    }

    Ok(result)
}

/// Split an ANSI sequence on a delimiter byte.
///
/// This is useful for parsing parameter lists separated by semicolons or colons.
#[inline]
pub fn split_on_byte(bytes: &[u8], delimiter: u8) -> impl Iterator<Item = &[u8]> {
    bytes.split(move |&b| b == delimiter)
}



impl ToAnsi for () {
    fn to_ansi(&self) -> impl AnsiEncode {
        ""
    }
}

impl AnsiEncode for &str {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        write_str_into(sink, self)
    }
}

impl AnsiEncode for String {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        write_str_into(sink, self)
    }
}

macro_rules! write_int_seq {
    ($(#[$meta:meta])* $type:ty) => {
        $(#[$meta])*
        impl $crate::encode::AnsiEncode for $type {
            #[inline]
            fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
                write_int(sink, *self)
            }
        }

        $(#[$meta])*
        impl $crate::encode::AnsiEncode for &$type {
            #[inline]
            fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
                write_int(sink, **self)
            }
        }

        $(#[$meta])*
        impl $crate::encode::AnsiEncode for &mut $type {
            #[inline]
            fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
                write_int(sink, **self)
            }
        }
    };
}

write_int_seq!(u8);
write_int_seq!(u16);
write_int_seq!(u32);
write_int_seq!(u64);
write_int_seq!(usize);
write_int_seq!(i8);
write_int_seq!(i16);
write_int_seq!(i32);
write_int_seq!(i64);
write_int_seq!(isize);

impl AnsiEncode for char {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        let mut buf = [0u8; 4];
        let s = self.encode_utf8(&mut buf);
        write_str_into(sink, s)
    }
}

impl AnsiEncode for &char {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        let mut buf = [0u8; 4];
        let s = self.encode_utf8(&mut buf);
        write_str_into(sink, s)
    }
}

impl AnsiEncode for &mut char {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        let mut buf = [0u8; 4];
        let s = self.encode_utf8(&mut buf);
        write_str_into(sink, s)
    }
}

impl AnsiEncode for bool {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        write_str_into(sink, if *self { "1" } else { "0" })
    }
}

impl AnsiEncode for &bool {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        write_str_into(sink, if **self { "1" } else { "0" })
    }
}

impl AnsiEncode for &mut bool {
    #[inline]
    fn encode_ansi_into<W: io::Write + ?Sized>(&self, sink: &mut W) -> Result<usize, EncodeError> {
        write_str_into(sink, if **self { "1" } else { "0" })
    }
}

/// Error type for ANSI parsing operations.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ParseError {
    /// The input has the wrong length.
    WrongLen { expected: usize, got: usize },
    /// The input contains an invalid value.
    InvalidValue(&'static str),
    /// The input contains an invalid byte at the specified position.
    InvalidByte { pos: usize, byte: u8 },
    /// The input is empty but a value was expected.
    Empty,
    /// The input contains an invalid UTF-8 sequence.
    InvalidUtf8,
    /// A custom error message.
    Custom(String),
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ParseError::WrongLen { expected, got } => {
                write!(f, "wrong length: expected {expected}, got {got}")
            }
            ParseError::InvalidValue(msg) => write!(f, "invalid value: {msg}"),
            ParseError::InvalidByte { pos, byte } => {
                write!(f, "invalid byte {byte:#04x} at position {pos}")
            }
            ParseError::Empty => write!(f, "empty input"),
            ParseError::InvalidUtf8 => write!(f, "invalid UTF-8 sequence"),
            ParseError::Custom(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for ParseError {}

#[derive(Debug)]
pub enum EncodeError {
    BufferOverflow(usize),
    IOError(std::io::Error),
}

impl From<EncodeError> for io::Error {
    fn from(err: EncodeError) -> Self {
        match err {
            EncodeError::BufferOverflow(n) => io::Error::new(
                io::ErrorKind::WriteZero,
                format!("buffer overflow: {n} bytes could not be written"),
            ),
            EncodeError::IOError(e) => e,
        }
    }
}

impl std::error::Error for EncodeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            EncodeError::IOError(e) => Some(e),
            EncodeError::BufferOverflow(_) => None,
        }
    }
}

impl fmt::Display for EncodeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EncodeError::BufferOverflow(n) => {
                write!(f, "buffer overflow: {n} bytes could not be written")
            }
            EncodeError::IOError(e) => write!(f, "I/O error: {e}"),
        }
    }
}

pub trait EncodedLen {
    /// Return the upper bound of the buffer size needed for `encode`.
    ///
    /// This value guarantees that `encode` will succeed with a buffer of
    /// this size. It does not have to be exact and should be computed as
    /// quickly as possible.
    fn encoded_buf_len(&self) -> usize;
}

/// Trait for types with a compile-time known encoded length.
///
/// This trait provides a constant upper bound for the buffer size needed to
/// encode a value. Types implementing this trait can have their buffer
/// requirements determined at compile time.
///
/// Types implementing this trait automatically get a default implementation
/// of [`EncodedLen::encoded_buf_len`] that returns this constant value.
pub trait StaticEncodedLen {
    /// The maximum number of bytes needed to encode this type.
    ///
    /// This value represents an upper bound that guarantees `encode` will
    /// succeed with a buffer of this size.
    const ENCODED_LEN: usize;
}

impl<T: StaticEncodedLen> EncodedLen for T {
    #[inline]
    fn encoded_buf_len(&self) -> usize {
        Self::ENCODED_LEN
    }
}

/// Trait for types that encode to a static byte sequence.
///
/// This trait is for types that always encode to the same constant string,
/// such as terminal control sequences without parameters. Types implementing
/// this trait automatically get `Encode`, `EncodedLen`, and `Write`
/// implementations via blanket impls.
pub trait StaticAnsiEncode {
    /// The static string this type encodes to.
    const STR: &'static str;
}

impl<T: StaticAnsiEncode> StaticEncodedLen for T {
    const ENCODED_LEN: usize = Self::STR.len();
}

impl<T: StaticAnsiEncode> ToAnsi for T {
    #[inline]
    fn to_ansi(&self) -> impl AnsiEncode {
        Self::STR
    }
}



/// Define a composite const encodeable that combines multiple encodeables.
#[macro_export]
macro_rules! const_composite {
    (
        $(#[$meta:meta])*
        $vis:vis struct $name:ident = [
            $($command:path),* $(,)?
        ];
    ) => {
        $(#[$meta])*
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        $vis struct $name;

        impl $crate::encode::StaticEncodedLen for $name {
            const ENCODED_LEN: usize = 0 $(+ <$command>::ENCODED_LEN)*;
        }

        impl $crate::encode::AnsiEncode for $name {
            #[inline]
            fn encode_ansi_into<W: ::std::io::Write + ?::std::marker::Sized>(
                &self,
                buf: &mut W
            ) -> Result<usize, $crate::encode::EncodeError> {
                // Use a stack-allocated buffer for const-length commands
                let mut stack_buf = [0u8; <Self as $crate::encode::StaticEncodedLen>::ENCODED_LEN];
                let mut offset = 0;

                $(
                    offset += $command.encode_ansi_into(&mut &mut stack_buf[offset..])?;
                )*

                buf.write_all(&stack_buf[..offset])
                    .map_err($crate::encode::EncodeError::IOError)?;
                Ok(offset)
            }
        }
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    use bytes::BufMut;

    struct TestCmd(&'static str);

    impl AnsiEncode for TestCmd {
        fn encode_ansi_into<W: io::Write + ?Sized>(&self, buf: &mut W) -> Result<usize, EncodeError> {
            write_str_into(buf, self.0)
        }
    }

    #[test]
    fn test_encode_with_bytesmut_writer() {
        use bytes::BytesMut;

        let mut buf = BytesMut::with_capacity(64).writer();
        TestCmd("Test").encode_ansi_into(&mut buf).unwrap();
        assert_eq!(&buf.get_ref().as_ref(), b"Test");
    }

    #[test]
    fn test_encode_ansi_into_slice() {
        let mut buf = [0u8; 64];
        let len = TestCmd("Hello").encode_ansi_into_slice(&mut buf).unwrap();
        assert_eq!(len, 5);
        assert_eq!(&buf[..len], b"Hello");
    }

    // Example: Fixed-length parser for a 3-byte color code
    #[derive(Debug, PartialEq, Eq)]
    struct RgbColor {
        r: u8,
        g: u8,
        b: u8,
    }

    fixed_length_ansi! {
        impl TryFromAnsiBytes<3> for RgbColor {
            fn try_from_ansi_bytes(bytes: &[u8; 3]) -> Result<Self, ParseError> {
                Ok(RgbColor {
                    r: bytes[0],
                    g: bytes[1],
                    b: bytes[2],
                })
            }
        }
    }

    #[test]
    fn test_try_from_ansi_bytes() {
        let color = RgbColor::try_from_ansi(&[255, 128, 64]).unwrap();
        assert_eq!(color, RgbColor { r: 255, g: 128, b: 64 });

        // Wrong length should fail
        let result = RgbColor::try_from_ansi(&[255, 128]);
        assert!(matches!(result, Err(ParseError::WrongLen { expected: 3, got: 2 })));
    }

    // Example: Variable-length parser
    #[derive(Debug, PartialEq, Eq)]
    struct AnsiString(String);

    impl<'a> TryFromAnsi<'a> for AnsiString {
        fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, ParseError> {
            let s = std::str::from_utf8(bytes)
                .map_err(|_| ParseError::InvalidUtf8)?;
            Ok(AnsiString(s.to_string()))
        }
    }

    #[test]
    fn test_try_from_ansi_variable() {
        let s = AnsiString::try_from_ansi(b"hello").unwrap();
        assert_eq!(s.0, "hello");

        let s2 = AnsiString::try_from_ansi(b"longer string").unwrap();
        assert_eq!(s2.0, "longer string");

        // Invalid UTF-8 should fail
        let result = AnsiString::try_from_ansi(&[0xFF, 0xFE]);
        assert!(matches!(result, Err(ParseError::InvalidUtf8)));
    }

    #[test]
    fn test_parse_error_display() {
        let err = ParseError::WrongLen { expected: 5, got: 3 };
        assert_eq!(err.to_string(), "wrong length: expected 5, got 3");

        let err = ParseError::InvalidValue("not a number");
        assert_eq!(err.to_string(), "invalid value: not a number");

        let err = ParseError::InvalidByte { pos: 2, byte: 0xFF };
        assert_eq!(err.to_string(), "invalid byte 0xff at position 2");
    }

    // Example: Using the macro for multiple types
    #[derive(Debug, PartialEq, Eq)]
    struct TwoBytes(u8, u8);

    fixed_length_ansi! {
        impl TryFromAnsiBytes<2> for TwoBytes {
            fn try_from_ansi_bytes(bytes: &[u8; 2]) -> Result<Self, ParseError> {
                Ok(TwoBytes(bytes[0], bytes[1]))
            }
        }
    }

    #[test]
    fn test_blanket_impl_bridge() {
        // TryFromAnsi is automatically implemented for TwoBytes
        let tb = TwoBytes::try_from_ansi(&[10, 20]).unwrap();
        assert_eq!(tb, TwoBytes(10, 20));

        let result = TwoBytes::try_from_ansi(&[10]);
        assert!(matches!(result, Err(ParseError::WrongLen { expected: 2, got: 1 })));
    }

    #[test]
    fn test_parse_single_byte() {
        assert_eq!(parse_single_byte(&[42]).unwrap(), 42);
        assert!(matches!(parse_single_byte(&[]), Err(ParseError::Empty)));
        assert!(matches!(
            parse_single_byte(&[1, 2]),
            Err(ParseError::WrongLen { expected: 1, got: 2 })
        ));
    }

    #[test]
    fn test_parse_utf8_str() {
        assert_eq!(parse_utf8_str(b"hello").unwrap(), "hello");
        assert!(matches!(parse_utf8_str(&[0xFF, 0xFE]), Err(ParseError::InvalidUtf8)));
    }

    #[test]
    fn test_parse_int() {
        assert_eq!(parse_int::<u32>(b"123").unwrap(), 123);
        assert_eq!(parse_int::<u32>(b"0").unwrap(), 0);
        assert_eq!(parse_int::<u16>(b"65535").unwrap(), 65535);

        assert!(matches!(parse_int::<u32>(b""), Err(ParseError::Empty)));
        assert!(matches!(
            parse_int::<u32>(b"12a34"),
            Err(ParseError::InvalidByte { pos: 2, byte: b'a' })
        ));
    }

    #[test]
    fn test_split_on_byte() {
        let parts: Vec<&[u8]> = split_on_byte(b"1;2;3", b';').collect();
        assert_eq!(parts, vec![b"1", b"2", b"3"]);

        let parts: Vec<&[u8]> = split_on_byte(b"100:200:300", b':').collect();
        assert_eq!(parts, vec![b"100", b"200", b"300"]);

        let parts: Vec<&[u8]> = split_on_byte(b"single", b';').collect();
        assert_eq!(parts, vec![b"single"]);
    }

    // Example: Infallible parsing with FromAnsiBytes
    #[derive(Debug, PartialEq, Eq)]
    struct OneByte(u8);

    fixed_length_ansi! {
        impl FromAnsiBytes<1> for OneByte {
            fn from_ansi_bytes(bytes: &[u8; 1]) -> Self {
                OneByte(bytes[0])
            }
        }
    }

    #[test]
    fn test_from_ansi_bytes_infallible() {
        // FromAnsiBytes is infallible
        let ob = OneByte::from_ansi_bytes(&[42]);
        assert_eq!(ob, OneByte(42));

        // TryFromAnsi is automatically generated and checks length
        let ob = OneByte::try_from_ansi(&[99]).unwrap();
        assert_eq!(ob, OneByte(99));

        let result = OneByte::try_from_ansi(&[1, 2]);
        assert!(matches!(result, Err(ParseError::WrongLen { expected: 1, got: 2 })));
    }

    // Example: Zero-copy parsing with lifetimes
    #[derive(Debug, PartialEq, Eq)]
    struct AnsiStr<'a>(&'a str);

    fixed_length_ansi! {
        impl<'a> TryFromAnsiBytes<5> for AnsiStr<'a> {
            fn try_from_ansi_bytes(bytes: &[u8; 5]) -> Result<Self, ParseError> {
                let s = parse_utf8_str(bytes)?;
                Ok(AnsiStr(s))
            }
        }
    }

    #[test]
    fn test_zero_copy_parsing() {
        // The parsed type borrows from the input
        let data = b"hello";
        let result = AnsiStr::try_from_ansi(data).unwrap();
        assert_eq!(result, AnsiStr("hello"));

        // Verify it's actually borrowing (this compiles because lifetimes work)
        let boxed_data = Box::new(*b"world");
        let result = AnsiStr::try_from_ansi(&boxed_data[..]).unwrap();
        assert_eq!(result.0, "world");
    }

    // Example: More complex zero-copy parsing with multiple borrowed fields
    #[derive(Debug, PartialEq, Eq)]
    struct ColorName<'a> {
        prefix: &'a [u8],
        name: &'a str,
    }

    fixed_length_ansi! {
        impl<'a> TryFromAnsiBytes<8> for ColorName<'a> {
            fn try_from_ansi_bytes(bytes: &[u8; 8]) -> Result<Self, ParseError> {
                // First 2 bytes are prefix, remaining 6 bytes are the name
                let prefix = &bytes[0..2];
                let name = parse_utf8_str(&bytes[2..8])?;
                Ok(ColorName { prefix, name })
            }
        }
    }

    #[test]
    fn test_zero_copy_complex() {
        let data = b"38yellow";
        let result = ColorName::try_from_ansi(data).unwrap();
        assert_eq!(result.prefix, b"38");
        assert_eq!(result.name, "yellow");

        // Both fields borrow from the original input
        let data = b"48green!";
        let result = ColorName::try_from_ansi(data).unwrap();
        assert_eq!(result, ColorName { prefix: b"48", name: "green!" });
    }

    // Example: Complex real-world use case - parsing CSI parameters
    // CSI sequences like "ESC[38;5;196m" have semicolon-separated parameters
    #[derive(Debug, PartialEq, Eq)]
    enum ColorMode {
        Indexed(u8),
        Rgb(u8, u8, u8),
    }

    #[derive(Debug, PartialEq, Eq)]
    struct SetForegroundColor {
        mode: ColorMode,
    }

    impl<'a> TryFromAnsi<'a> for SetForegroundColor {
        fn try_from_ansi(bytes: &'a [u8]) -> Result<Self, ParseError> {
            let parts: Vec<&[u8]> = split_on_byte(bytes, b';').collect();

            match parts.as_slice() {
                // Format: 38;5;N (indexed color)
                [b"38", b"5", index] => {
                    let idx = parse_int::<u8>(index)?;
                    Ok(SetForegroundColor {
                        mode: ColorMode::Indexed(idx),
                    })
                }
                // Format: 38;2;R;G;B (RGB color)
                [b"38", b"2", r, g, b] => {
                    let red = parse_int::<u8>(r)?;
                    let green = parse_int::<u8>(g)?;
                    let blue = parse_int::<u8>(b)?;
                    Ok(SetForegroundColor {
                        mode: ColorMode::Rgb(red, green, blue),
                    })
                }
                _ => Err(ParseError::InvalidValue("invalid color sequence")),
            }
        }
    }

    #[test]
    fn test_parse_csi_color_indexed() {
        let color = SetForegroundColor::try_from_ansi(b"38;5;196").unwrap();
        assert_eq!(
            color,
            SetForegroundColor {
                mode: ColorMode::Indexed(196)
            }
        );
    }

    #[test]
    fn test_parse_csi_color_rgb() {
        let color = SetForegroundColor::try_from_ansi(b"38;2;255;128;64").unwrap();
        assert_eq!(
            color,
            SetForegroundColor {
                mode: ColorMode::Rgb(255, 128, 64)
            }
        );
    }

    #[test]
    fn test_parse_csi_color_invalid() {
        let result = SetForegroundColor::try_from_ansi(b"38;9;100");
        assert!(matches!(result, Err(ParseError::InvalidValue(_))));

        let result = SetForegroundColor::try_from_ansi(b"38;2;255");
        assert!(matches!(result, Err(ParseError::InvalidValue(_))));
    }
}
